# StoryCraft AI

## Краткий алгоритм работы

1. Отрисовка интерфейса и инициализация WebSocket.
2. Ожидание нажатия кнопки "Старт" пользователем.
3. Формирование начального промпта истории.
4. Генерация текста сюжета с выбором продолжения.
5. Поиск вариантов продолжения сюжета и создание кнопок выбора.
6. Генерация промпта для иллюстрации к рассказанному сегменту.
7. Отображение вариантов выбора.
8. Отправка на генерацию иллюстрации.
9. Полученную иллюстрацию вставляем в рассказанную секцию сюжета.

При нажатии кнопки с вариантом сюжета продолжаем генерацию следующей секции сюжета.

## Пошаговый алгоритм работы

### 1. Инициализация системы
1. **Запуск сервера** (`main.py`)
   - Инициализация FastAPI приложения:
     * Настройка маршрутов API
     * Конфигурация CORS (разрешение кросс-доменных запросов с фронтенда) и middleware (обработка сессий, аутентификация, логирование)
   - Настройка WebSocket для real-time коммуникации
   - Загрузка конфигураций:
     * `config/ollama_config.py`:
       - model: модель для генерации текста
       - host: адрес API Ollama
       - system_prompts:
         + story_generation.py - основной промпт для генерации историй
         + image_description.py - промпт для описания сцен
         + choice_generation.py - промпт для генерации выборов
       - parameters:
         + num_predict: максимальное количество токенов для генерации
         + temperature: параметр креативности генерации
         + top_k: количество лучших токенов для выбора
         + top_p: порог вероятности для выбора токенов
         + repeat_penalty: штраф за повторение слов
     * `config/comfy_config.py`:
       - host: адрес API ComfyUI
       - workflow: файл с настройками рабочего процесса
       - models:
         + checkpoint: основная модель для генерации
         + vae: модель для кодирования/декодирования изображений
         + lora: дополнительная модель для улучшения деталей
       - parameters:
         + seed: зерно для воспроизводимости результатов
         + steps: количество шагов генерации
         + cfg: сила следования промпту
         + sampler_name: алгоритм сэмплирования
         + scheduler: тип планировщика шагов
         + denoise: сила шумоподавления
         + style_preset: базовый стиль изображения
   - Проверка доступности сервисов:
     * Ollama API
     * ComfyUI API
   - Подготовка очередей сообщений

2. **Подготовка frontend** (`static/js/main.js`)
   - Загрузка интерфейса:
     * Инициализация WebSocket соединения
     * Настройка обработчиков событий
     * Подготовка контейнеров для контента
   - Параметры соединения (`static/js/websocket/config.js`):
     * Автоматическое переподключение:
       - reconnectInterval: интервал между попытками
       - maxReconnectAttempts: максимальное число попыток
       - backoffMultiplier: множитель для интервала
     * Обработка таймаутов:
       - connectionTimeout: таймаут установки соединения
       - messageTimeout: таймаут ожидания ответа
       - pingInterval: интервал проверки соединения
     * Буферизация сообщений:
       - messageQueueSize: размер очереди сообщений
       - batchSize: размер пакета для отправки
       - flushInterval: интервал очистки буфера

### 2. Генерация истории
1. **Фаза стриминга текста** (`app/services/ollama/story_generator.py`)
   - Формирование системного промпта:
     * Модули с промптами (`app/services/ollama/prompts/`):
       + story_generation.py:
         - MAIN_PROMPT - основной промпт для сюжета
         - CHAPTER_START - начало новой главы
         - STORY_CONTINUATION - продолжение истории
       + choice_generation.py:
         - CHOICE_FORMAT - формат генерации выборов
         - CHOICE_COUNT - количество вариантов
         - CHOICE_RULES - правила для выборов
       + image_description.py:
         - SCENE_EXTRACTION - выделение описания сцены
         - STYLE_GUIDELINES - стилистические указания
         - VISUAL_DETAILS - детали для визуализации
     * Инструкции для стиля повествования (в `story_generator.py`, system_prompt для первой главы):
       - Стилистические требования в разделе 4 промпта
       - Художественные приёмы и язык повествования
     * Требования к структуре текста (в `story_generator.py`):
       - Для первой главы: разделы 1-3 в system_prompt для "начало истории"
       - Для следующих глав: правила 1-6 в system_prompt для продолжения
     * Правила формирования выборов (в `story_generator.py`):
       - Для первой главы: раздел 5 в system_prompt
       - Для следующих глав: правило 7 в system_prompt продолжения
   - Потоковая генерация:
     * Отправка частей текста через WebSocket
     * Обновление интерфейса в реальном времени
     * Сбор полного текста для анализа

2. **Фаза формирования контента** (`app/api/routes/story.py`)
   - Анализ сгенерированного текста:
     * Выделение основного повествования
     * Извлечение вариантов выбора (regex: r'^\\d+[\\.\\)]|^\\*+')
     * Определение ключевых моментов для иллюстрации
   - Структурирование данных:
     * Форматирование текста
     * Подготовка кнопок выбора
     * Метаданные для иллюстрации

### 3. Создание иллюстрации
1. **Подготовка описания сцены** (`app/services/ollama/story_generator.py`)
   - Анализ текста сегмента:
     * Фильтрация диалогов (regex: r'"[^"]*"')
     * Удаление опций выбора
     * Исключение вопросов (regex: r'[^.!?]+\\?')
   - Создание английского описания:
     * Системный промпт для визуального описания
     * Лимит в 30 слов
     * Проверка на кириллицу (regex: [а-яА-Я])
     * До 3-х попыток генерации
     * Fallback: "A mysterious scene with dark atmosphere"

2. **Генерация изображения** (`app/services/comfy/image_generator.py`)
   - Подготовка GPU:
     * Выгрузка моделей Ollama (POST /api/unload)
     * Очистка кэша ComfyUI (POST /free)
     * Проверка памяти (минимум 2GB)
   - Параметры ComfyUI workflow:
     * KSampler - настройки сэмплера
     * CheckpointLoaderSimple - загрузка модели
     * VAELoader - настройки VAE
     * CLIPTextEncode - кодирование текста
   - Обработка результата:
     * Конвертация в base64
     * Привязка к сегменту
     * Отправка на frontend

### 4. Управление ресурсами
1. **Память GPU** (`app/services/comfy/image_generator.py`)
   - Мониторинг через ComfyUI API:
     * GET /system_stats
     * Проверка свободной памяти
   - Управление моделями:
     * Автоматическая выгрузка
     * Очистка кэша
     * Перезапуск сервисов
   - Параметры моделей:
     * gpu_layers: 27
     * num_gpu: 1
     * gpu_memory_utilization: 0.8

2. **Обработка ошибок** (`app/services/ollama/story_generator.py`)
   - Система повторных попыток:
     * max_retries: 3
     * retry_delay: exponential backoff
   - Механизмы fallback:
     * Базовые промпты
     * Альтернативные модели
   - Логирование:
     * Уровень: INFO
     * Формат: [GENERATOR] >>> действие

### 5. Взаимодействие с пользователем
1. **Обработка выбора** (`app/api/routes/story.py`)
   - Получение выбора:
     * Валидация входных данных
     * Обновление контекста
   - Сохранение истории:
     * Последние 3 выбора
     * Текущая глава
     * Состояние сессии

2. **Отображение контента** (`static/js/main.js`)
   - Frontend обновления:
     * Анимация текста
     * Загрузка изображений
     * Состояние кнопок
   - WebSocket события:
     * onmessage - обновление контента
     * onerror - обработка ошибок
     * onclose - переподключение

## Алгоритм работы Story Generator

## 1. Управление контекстом истории

### 1.1 Структура контекста
```python
StoryContext = {
    "character": {
        "gender": str,    # "мужской"/"женский"/"-"
        "age": str,       # конкретный возраст или "неизвестно"
        "name": str|None  # имя персонажа или None
    },
    "location": str,      # текущая локация
    "events": List[str]   # список ключевых событий
}
```

### 1.2 Анализ контекста (analyze_context)
1. Получение текста сцены
2. Извлечение информации:
   - Определение пола персонажа по ключевым словам ("герой"/"он"/"его")
   - Поиск упоминаний возраста
   - Поиск имени персонажа
   - Определение текущей локации
   - Выделение ключевых событий

### 1.3 Обновление контекста (update_story_context)
1. Анализ нового текста
2. Слияние с существующим контекстом:
   - Сохранение известной информации о персонаже
   - Обновление локации при изменении
   - Добавление новых событий в хронологию

## 2. Хронология событий

### 2.1 Правила ведения хронологии
1. События добавляются в порядке их появления
2. Каждое событие должно быть:
   - Кратким (до 100 символов)
   - Информативным
   - Описывать завершенное действие
3. Не включаются:
   - Варианты выбора
   - Описания окружения
   - Внутренние мысли
   - Планы на будущее

### 2.2 Фильтрация событий
1. Игнорировать текст после маркеров:
   - "Варианты действий:"
   - "Выбор:"
2. Выделять только значимые действия:
   - Перемещения персонажа
   - Взаимодействия с предметами/персонажами
   - Важные находки/открытия
   - Ключевые решения

### 2.3 Обработка выборов
1. При совершении выбора:
   - Добавить выбранное действие в хронологию
   - Игнорировать отвергнутые варианты
2. Отслеживать последствия выбора:
   - Изменения локации
   - Новые события
   - Влияние на состояние персонажа

## 3. Отображение информации

### 3.1 Интерфейс
1. Блок информации о персонаже:
   - Пол
   - Возраст
   - Имя (если известно)
2. Текущая локация:
   - Название места
   - Краткое описание
3. Хронология:
   - Список событий
   - Последние 3-5 событий выделены

### 3.2 Обновление UI
1. Динамическое обновление при:
   - Получении новой сцены
   - Совершении выбора
   - Изменении контекста
2. Анимация изменений:
   - Плавное появление новых событий
   - Подсветка изменений
   - Индикация обновления информации

## 4. Обработка ошибок

### 4.1 Стратегии восстановления
1. При ошибке анализа:
   - Сохранение предыдущего контекста
   - Логирование ошибки
   - Возврат безопасных значений по умолчанию
2. При неполных данных:
   - Использование placeholder значений
   - Пометка неопределенной информации
   - Продолжение работы с доступными данными

### 4.2 Валидация данных
1. Проверка формата контекста
2. Валидация новых событий
3. Контроль целостности хронологии

## 5. Улучшения и оптимизации

### 5.1 Приоритетные задачи
1. Улучшение определения пола персонажа
2. Более точное выделение событий
3. Умное объединение похожих событий
4. Контроль размера хронологии

### 5.2 Будущие улучшения
1. Анализ эмоционального состояния
2. Отслеживание отношений с NPC
3. Карта исследованных локаций
4. Система достижений
